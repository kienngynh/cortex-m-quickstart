[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Rust Embedded Quickstart",
    "section": "",
    "text": "1 Preface",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Bắt đầu với cortex-m-quickstart vì tôi muốn biết thêm rằng có thể chạy giả lập phần cứng với qemu nếu không có phần cứng tôi cần, và tôi muốn học thêm điều đó.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "Summary",
    "section": "",
    "text": "Do thấy có nhiều thuật ngữ khó hiểu khi mới bắt đầu học Rust Embedded, tôi viết sách này giải thích những thuật ngữ đó trong quá trình học.",
    "crumbs": [
      "Summary"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "index.html#giải-thích-các-file-trong-dự-án-cortex-m-quickstart",
    "href": "index.html#giải-thích-các-file-trong-dự-án-cortex-m-quickstart",
    "title": "My Rust Embedded Quickstart",
    "section": "1.2 Giải thích các file trong dự án cortex-m-quickstart",
    "text": "1.2 Giải thích các file trong dự án cortex-m-quickstart\nDự án cortex-m-quickstart cung cấp một template cơ bản để xây dựng ứng dụng cho vi điều khiển ARM Cortex-M.\n\n1.2.1 .cargo/config.toml:\nFile cấu hình cho cargo, công cụ quản lý dự án Rust. File này xác định target (mục tiêu) biên dịch mặc định cho dự án. Bạn có thể chọn một trong các target được liệt kê trong file này, tùy thuộc vào loại vi điều khiển Cortex-M mà bạn đang sử dụng.\n\n\n1.2.2 memory.x:\nFile này chứa thông tin về vùng nhớ (memory region) của vi điều khiển. Nó xác định vị trí bắt đầu (ORIGIN) và kích thước (LENGTH) của các vùng nhớ như Flash và RAM. Thông tin này được sử dụng bởi linker để phân bổ bộ nhớ cho chương trình.\n\n\n1.2.3 src/main.rs:\nFile này chứa mã nguồn chính của ứng dụng. Nó là điểm khởi đầu của chương trình và chứa các hàm chính để khởi tạo và chạy ứng dụng.\n\n\n1.2.4 Cargo.toml:\nFile này chứa thông tin về dự án, bao gồm tên dự án, phiên bản, phụ thuộc, tác giả, v.v. Nó được sử dụng bởi cargo để quản lý dự án.\n\n\n1.2.5 openocd.cfg:\nFile này chứa cấu hình cho OpenOCD, một công cụ để lập trình và gỡ lỗi vi điều khiển. Nó xác định các thông số kết nối với vi điều khiển, bao gồm loại vi điều khiển, giao thức kết nối (ví dụ: JTAG, SWD), tốc độ truyền dữ liệu, v.v. File này cũng có thể chứa các lệnh để khởi động lại vi điều khiển, tải chương trình vào bộ nhớ Flash, v.v.\n\n\n1.2.6 openocd.gdb:\nFile này chứa cấu hình cho GDB, một công cụ gỡ lỗi. Nó xác định các thông số kết nối với OpenOCD, bao gồm địa chỉ IP và cổng của OpenOCD server. File này cũng có thể chứa các lệnh để tải chương trình vào bộ nhớ, đặt điểm dừng (breakpoint), xem giá trị biến, v.v.\n\n\n1.2.7 build.rs:\nFile build.rs là một file đặc biệt trong Rust được sử dụng để thực hiện các tác vụ xây dựng trước khi biên dịch chính thức. Nó được chạy bởi cargo trước khi biên dịch mã nguồn chính của dự án.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "index.html#cấu-trúc-và-các-đường-dẫn-tiêu-chuẩn-trong-một-dự-án-rust",
    "href": "index.html#cấu-trúc-và-các-đường-dẫn-tiêu-chuẩn-trong-một-dự-án-rust",
    "title": "My Rust Embedded Quickstart",
    "section": "1.1 Cấu trúc và các đường dẫn tiêu chuẩn trong một dự án Rust",
    "text": "1.1 Cấu trúc và các đường dẫn tiêu chuẩn trong một dự án Rust\nDự án Rust thường tuân theo một cấu trúc tiêu chuẩn để tổ chức mã nguồn và các tệp liên quan. Dưới đây là một số đường dẫn tiêu chuẩn và cấu trúc phổ biến:\n\n1.1.1 Thư mục gốc:\nCargo.toml: File cấu hình chính của dự án, chứa thông tin về tên dự án, phiên bản, phụ thuộc, tác giả, v.v.\nsrc/: Thư mục chứa mã nguồn chính của dự án. main.rs: Điểm khởi đầu của chương trình, chứa hàm main() chính.\nlib.rs: File chứa mã nguồn của thư viện (library) của dự án.\nexamples/: Thư mục chứa các ví dụ mã nguồn.\ntests/: Thư mục chứa các bài kiểm tra đơn vị (unit tests) cho dự án.\nbenches/: Thư mục chứa các bài kiểm tra hiệu năng (benchmark tests) cho dự án.\ntarget/: Thư mục chứa các file được tạo ra trong quá trình biên dịch, bao gồm các file thực thi, thư viện, v.v.\n.gitignore: File chứa danh sách các file và thư mục không nên được theo dõi bởi Git.\n\n\n1.1.2 Thư mục src/:\nmain.rs: File chứa hàm main() chính, điểm khởi đầu của chương trình. lib.rs: File chứa mã nguồn của thư viện (library) của dự án. Thư viện có thể được sử dụng bởi các dự án khác. Các file khác: Có thể có các file khác trong thư mục src/ để tổ chức mã nguồn theo các module hoặc chức năng cụ thể.\n\n\n1.1.3 Thư mục examples/:\nCác file ví dụ: Thư mục này chứa các file ví dụ mã nguồn để minh họa cách sử dụng thư viện hoặc chức năng của dự án.\n\n\n1.1.4 Thư mục tests/:\nCác file kiểm tra: Thư mục này chứa các file kiểm tra đơn vị (unit tests) để kiểm tra chức năng của mã nguồn.\n\n\n1.1.5 Thư mục benches/:\nCác file kiểm tra hiệu năng: Thư mục này chứa các file kiểm tra hiệu năng (benchmark tests) để đo lường hiệu suất của mã nguồn.\n\n\n1.1.6 Thư mục target/:\nCác file được tạo ra: Thư mục này chứa các file được tạo ra trong quá trình biên dịch, bao gồm các file thực thi, thư viện, v.v.\n\n\n1.1.7 File .gitignore:\nDanh sách các file không theo dõi: File này chứa danh sách các file và thư mục không nên được theo dõi bởi Git. Lưu ý:\nCấu trúc này có thể thay đổi tùy thuộc vào yêu cầu của dự án cụ thể. Bạn có thể thêm hoặc xóa các thư mục và file theo nhu cầu. Việc tuân theo cấu trúc tiêu chuẩn giúp cho dự án dễ dàng quản lý và bảo trì hơn.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "config-toml.html",
    "href": "config-toml.html",
    "title": "2  .cargo/config.toml",
    "section": "",
    "text": "2.1 [target.thumbv7m-none-eabi]:\nPhần này xác định các tùy chọn cấu hình cho target thumbv7m-none-eabi, tương ứng với vi điều khiển ARM Cortex-M3. runner = “qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -kernel”: Câu lệnh này xác định cách chạy chương trình sau khi biên dịch. Nó sử dụng QEMU, một trình giả lập, để chạy chương trình trên vi điều khiển Cortex-M3. Các tham số được sử dụng để cấu hình QEMU, bao gồm loại CPU, loại máy, chế độ hiển thị, v.v.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>.cargo/config.toml</span>"
    ]
  },
  {
    "objectID": "config-toml.html#target.cfgalltarget_arch-arm-target_os-none",
    "href": "config-toml.html#target.cfgalltarget_arch-arm-target_os-none",
    "title": "2  .cargo/config.toml",
    "section": "2.2 [target.’cfg(all(target_arch = “arm”, target_os = “none”))’]:",
    "text": "2.2 [target.’cfg(all(target_arch = “arm”, target_os = “none”))’]:\nPhần này xác định các tùy chọn cấu hình cho target ARM Cortex-M, được xác định bởi target_arch = “arm” và target_os = “none”. runner = “arm-none-eabi-gdb -q -x openocd.gdb”: Câu lệnh này xác định cách chạy chương trình sau khi biên dịch. Nó sử dụng arm-none-eabi-gdb, một trình gỡ lỗi, để chạy chương trình trong chế độ gỡ lỗi. Các tham số được sử dụng để cấu hình GDB, bao gồm chế độ im lặng (-q) và file cấu hình (-x openocd.gdb). runner = “gdb-multiarch -q -x openocd.gdb”: Câu lệnh này tương tự như câu lệnh trên, nhưng sử dụng gdb-multiarch thay vì arm-none-eabi-gdb. runner = “gdb -q -x openocd.gdb”: Câu lệnh này tương tự như câu lệnh trên, nhưng sử dụng gdb thay vì arm-none-eabi-gdb hoặc gdb-multiarch.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>.cargo/config.toml</span>"
    ]
  },
  {
    "objectID": "config-toml.html#rustflags",
    "href": "config-toml.html#rustflags",
    "title": "2  .cargo/config.toml",
    "section": "2.3 rustflags = […]:",
    "text": "2.3 rustflags = […]:\nPhần này xác định các cờ biên dịch (flags) cho Rust. “-C”, “linker=arm-none-eabi-ld”: Câu lệnh này xác định trình liên kết (linker) được sử dụng để liên kết các file đối tượng (object files) thành file thực thi. Nó sử dụng trình liên kết LLD, được cung cấp bởi Rust toolchain. “-C”, “linker=arm-none-eabi-gcc”: Câu lệnh này xác định trình liên kết được sử dụng để liên kết các file đối tượng. Nó sử dụng trình liên kết GCC, được cung cấp bởi toolchain C. “-C”, “link-arg=-Wl,-Tlink.x”: Câu lệnh này truyền tham số -Tlink.x cho trình liên kết. Tham số này được sử dụng để xác định file script liên kết, chứa thông tin về cách liên kết các file đối tượng. “-C”, “link-arg=-nostartfiles”: Câu lệnh này truyền tham số -nostartfiles cho trình liên kết. Tham số này được sử dụng để ngăn trình liên kết thêm các file khởi động (startup files) vào file thực thi.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>.cargo/config.toml</span>"
    ]
  },
  {
    "objectID": "config-toml.html#build",
    "href": "config-toml.html#build",
    "title": "2  .cargo/config.toml",
    "section": "2.4 [build]:",
    "text": "2.4 [build]:\nPhần này xác định các tùy chọn cấu hình cho quá trình xây dựng (build). target = “thumbv7m-none-eabi”: Câu lệnh này xác định target (mục tiêu) biên dịch mặc định cho dự án. Nó sử dụng target thumbv7m-none-eabi, tương ứng với vi điều khiển ARM Cortex-M3. Lưu ý:\nFile .cargo/config.toml là tùy chọn và không phải lúc nào cũng cần thiết. Bạn có thể thêm hoặc xóa các phần và tùy chọn cấu hình theo nhu cầu của dự án. Việc sử dụng file .cargo/config.toml giúp bạn cấu hình dự án một cách linh hoạt và dễ dàng hơn.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>.cargo/config.toml</span>"
    ]
  },
  {
    "objectID": "config-toml.html#target.thumbv7m-none-eabi",
    "href": "config-toml.html#target.thumbv7m-none-eabi",
    "title": "2  .cargo/config.toml",
    "section": "",
    "text": "2.1.1 QEMU\nQEMU (Quick Emulator) là một trình giả lập phần cứng mã nguồn mở, cho phép bạn chạy các hệ điều hành và ứng dụng được thiết kế cho một kiến trúc phần cứng khác trên một kiến trúc phần cứng khác. Nói cách khác, QEMU cho phép bạn mô phỏng một máy tính khác trên máy tính hiện tại của bạn.\nCách hoạt động của QEMU:\nQEMU hoạt động bằng cách tạo ra một môi trường ảo hóa, mô phỏng các thành phần phần cứng của máy tính mục tiêu, bao gồm:\nCPU: QEMU mô phỏng CPU của máy tính mục tiêu, bao gồm các bộ lệnh, bộ nhớ cache, v.v. Bộ nhớ: QEMU tạo ra một vùng nhớ ảo, mô phỏng bộ nhớ của máy tính mục tiêu. Thiết bị ngoại vi: QEMU mô phỏng các thiết bị ngoại vi như ổ cứng, card mạng, card đồ họa, v.v. Sử dụng QEMU:\nQEMU có thể được sử dụng cho nhiều mục đích, bao gồm:\nKiểm tra phần mềm: QEMU cho phép bạn kiểm tra phần mềm trên nhiều kiến trúc phần cứng khác nhau mà không cần phải có phần cứng thực tế. Phát triển phần mềm: QEMU cho phép bạn phát triển phần mềm cho các hệ điều hành và kiến trúc phần cứng khác nhau mà không cần phải có phần cứng thực tế. Giáo dục: QEMU là một công cụ hữu ích cho việc học hỏi về kiến trúc phần cứng và hệ điều hành. Bảo mật: QEMU có thể được sử dụng để tạo ra các môi trường ảo hóa an toàn để chạy các ứng dụng nhạy cảm. Ví dụ:\nTrong dự án cortex-m-quickstart, QEMU được sử dụng để chạy chương trình được biên dịch cho vi điều khiển ARM Cortex-M3. Câu lệnh qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -kernel trong file .cargo/config.toml xác định cách chạy chương trình bằng QEMU.\nqemu-system-arm: Chạy QEMU cho kiến trúc ARM. -cpu cortex-m3: Sử dụng CPU Cortex-M3. -machine lm3s6965evb: Sử dụng bo mạch LM3S6965EVB. -nographic: Không hiển thị giao diện đồ họa. -semihosting-config enable=on,target=native: Cấu hình chế độ semihosting để cho phép chương trình tương tác với máy chủ QEMU. -kernel: Chạy chương trình được biên dịch. Kết luận:\nQEMU là một công cụ mạnh mẽ và linh hoạt cho việc mô phỏng phần cứng và chạy các hệ điều hành và ứng dụng trên các kiến trúc phần cứng khác nhau. Nó là một công cụ hữu ích cho nhiều mục đích, bao gồm kiểm tra phần mềm, phát triển phần mềm, giáo dục và bảo mật.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>.cargo/config.toml</span>"
    ]
  }
]