% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrreprt}

\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else  
    % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\setcounter{secnumdepth}{5}
% Make \paragraph and \subparagraph free-standing
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi


\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
% definitions for citeproc citations
\NewDocumentCommand\citeproctext{}{}
\NewDocumentCommand\citeproc{mm}{%
  \begingroup\def\citeproctext{#2}\cite{#1}\endgroup}
\makeatletter
 % allow citations to break across lines
 \let\@cite@ofmt\@firstofone
 % avoid brackets around text for \cite:
 \def\@biblabel#1{}
 \def\@cite#1#2{{#1\if@tempswa , #2\fi}}
\makeatother
\newlength{\cslhangindent}
\setlength{\cslhangindent}{1.5em}
\newlength{\csllabelwidth}
\setlength{\csllabelwidth}{3em}
\newenvironment{CSLReferences}[2] % #1 hanging-indent, #2 entry-spacing
 {\begin{list}{}{%
  \setlength{\itemindent}{0pt}
  \setlength{\leftmargin}{0pt}
  \setlength{\parsep}{0pt}
  % turn on hanging indent if param 1 is 1
  \ifodd #1
   \setlength{\leftmargin}{\cslhangindent}
   \setlength{\itemindent}{-1\cslhangindent}
  \fi
  % set entry spacing
  \setlength{\itemsep}{#2\baselineskip}}}
 {\end{list}}
\usepackage{calc}
\newcommand{\CSLBlock}[1]{\hfill\break\parbox[t]{\linewidth}{\strut\ignorespaces#1\strut}}
\newcommand{\CSLLeftMargin}[1]{\parbox[t]{\csllabelwidth}{\strut#1\strut}}
\newcommand{\CSLRightInline}[1]{\parbox[t]{\linewidth - \csllabelwidth}{\strut#1\strut}}
\newcommand{\CSLIndent}[1]{\hspace{\cslhangindent}#1}

\KOMAoption{captions}{tableheading}
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage{bookmark}

\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  pdftitle={My Rust Embedded Quickstart},
  pdfauthor={Kevil Nguyen},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}

\title{My Rust Embedded Quickstart}
\author{Kevil Nguyen}
\date{2024-06-13}

\begin{document}
\maketitle

\renewcommand*\contentsname{Table of contents}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}
\bookmarksetup{startatroot}

\chapter{Preface}\label{preface}

\section{Cấu trúc và các đường dẫn tiêu chuẩn trong một dự án
Rust}\label{cux1ea5u-truxfac-vuxe0-cuxe1c-ux111ux1b0ux1eddng-dux1eabn-tiuxeau-chuux1ea9n-trong-mux1ed9t-dux1ef1-uxe1n-rust}

Dự án Rust thường tuân theo một cấu trúc tiêu chuẩn để tổ chức mã nguồn
và các tệp liên quan. Dưới đây là một số đường dẫn tiêu chuẩn và cấu
trúc phổ biến:

\subsection{Thư mục gốc:}\label{thux1b0-mux1ee5c-gux1ed1c}

Cargo.toml: File cấu hình chính của dự án, chứa thông tin về tên dự án,
phiên bản, phụ thuộc, tác giả, v.v.

src/: Thư mục chứa mã nguồn chính của dự án. main.rs: Điểm khởi đầu của
chương trình, chứa hàm main() chính.

lib.rs: File chứa mã nguồn của thư viện (library) của dự án.

examples/: Thư mục chứa các ví dụ mã nguồn.

tests/: Thư mục chứa các bài kiểm tra đơn vị (unit tests) cho dự án.

benches/: Thư mục chứa các bài kiểm tra hiệu năng (benchmark tests) cho
dự án.

target/: Thư mục chứa các file được tạo ra trong quá trình biên dịch,
bao gồm các file thực thi, thư viện, v.v.

.gitignore: File chứa danh sách các file và thư mục không nên được theo
dõi bởi Git.

\subsection{Thư mục src/:}\label{thux1b0-mux1ee5c-src}

main.rs: File chứa hàm main() chính, điểm khởi đầu của chương trình.
lib.rs: File chứa mã nguồn của thư viện (library) của dự án. Thư viện có
thể được sử dụng bởi các dự án khác. Các file khác: Có thể có các file
khác trong thư mục src/ để tổ chức mã nguồn theo các module hoặc chức
năng cụ thể.

\subsection{Thư mục examples/:}\label{thux1b0-mux1ee5c-examples}

Các file ví dụ: Thư mục này chứa các file ví dụ mã nguồn để minh họa
cách sử dụng thư viện hoặc chức năng của dự án.

\subsection{Thư mục tests/:}\label{thux1b0-mux1ee5c-tests}

Các file kiểm tra: Thư mục này chứa các file kiểm tra đơn vị (unit
tests) để kiểm tra chức năng của mã nguồn.

\subsection{Thư mục benches/:}\label{thux1b0-mux1ee5c-benches}

Các file kiểm tra hiệu năng: Thư mục này chứa các file kiểm tra hiệu
năng (benchmark tests) để đo lường hiệu suất của mã nguồn.

\subsection{Thư mục target/:}\label{thux1b0-mux1ee5c-target}

Các file được tạo ra: Thư mục này chứa các file được tạo ra trong quá
trình biên dịch, bao gồm các file thực thi, thư viện, v.v.

\subsection{File .gitignore:}\label{file-.gitignore}

Danh sách các file không theo dõi: File này chứa danh sách các file và
thư mục không nên được theo dõi bởi Git. Lưu ý:

Cấu trúc này có thể thay đổi tùy thuộc vào yêu cầu của dự án cụ thể. Bạn
có thể thêm hoặc xóa các thư mục và file theo nhu cầu. Việc tuân theo
cấu trúc tiêu chuẩn giúp cho dự án dễ dàng quản lý và bảo trì hơn.

\section{Giải thích các file trong dự án
cortex-m-quickstart}\label{giux1ea3i-thuxedch-cuxe1c-file-trong-dux1ef1-uxe1n-cortex-m-quickstart}

Dự án cortex-m-quickstart cung cấp một template cơ bản để xây dựng ứng
dụng cho vi điều khiển ARM Cortex-M.

\subsection{.cargo/config.toml:}\label{cargoconfig.toml}

File cấu hình cho cargo, công cụ quản lý dự án Rust. File này xác định
target (mục tiêu) biên dịch mặc định cho dự án. Bạn có thể chọn một
trong các target được liệt kê trong file này, tùy thuộc vào loại vi điều
khiển Cortex-M mà bạn đang sử dụng.

\subsection{memory.x:}\label{memory.x}

File này chứa thông tin về vùng nhớ (memory region) của vi điều khiển.
Nó xác định vị trí bắt đầu (ORIGIN) và kích thước (LENGTH) của các vùng
nhớ như Flash và RAM. Thông tin này được sử dụng bởi linker để phân bổ
bộ nhớ cho chương trình.

\subsection{src/main.rs:}\label{srcmain.rs}

File này chứa mã nguồn chính của ứng dụng. Nó là điểm khởi đầu của
chương trình và chứa các hàm chính để khởi tạo và chạy ứng dụng.

\subsection{Cargo.toml:}\label{cargo.toml}

File này chứa thông tin về dự án, bao gồm tên dự án, phiên bản, phụ
thuộc, tác giả, v.v. Nó được sử dụng bởi cargo để quản lý dự án.

\subsection{openocd.cfg:}\label{openocd.cfg}

File này chứa cấu hình cho OpenOCD, một công cụ để lập trình và gỡ lỗi
vi điều khiển. Nó xác định các thông số kết nối với vi điều khiển, bao
gồm loại vi điều khiển, giao thức kết nối (ví dụ: JTAG, SWD), tốc độ
truyền dữ liệu, v.v. File này cũng có thể chứa các lệnh để khởi động lại
vi điều khiển, tải chương trình vào bộ nhớ Flash, v.v.

\subsection{openocd.gdb:}\label{openocd.gdb}

File này chứa cấu hình cho GDB, một công cụ gỡ lỗi. Nó xác định các
thông số kết nối với OpenOCD, bao gồm địa chỉ IP và cổng của OpenOCD
server. File này cũng có thể chứa các lệnh để tải chương trình vào bộ
nhớ, đặt điểm dừng (breakpoint), xem giá trị biến, v.v.

\subsection{build.rs:}\label{build.rs}

File build.rs là một file đặc biệt trong Rust được sử dụng để thực hiện
các tác vụ xây dựng trước khi biên dịch chính thức. Nó được chạy bởi
cargo trước khi biên dịch mã nguồn chính của dự án.

\bookmarksetup{startatroot}

\chapter*{Introduction}\label{introduction}
\addcontentsline{toc}{chapter}{Introduction}

\markboth{Introduction}{Introduction}

Bắt đầu với cortex-m-quickstart vì tôi muốn biết thêm rằng có thể chạy
giả lập phần cứng với qemu nếu không có phần cứng tôi cần, và tôi muốn
học thêm điều đó.

\bookmarksetup{startatroot}

\chapter{.cargo/config.toml}\label{cargoconfig.toml-1}

File .cargo/config.toml là file cấu hình cho cargo, công cụ quản lý dự
án Rust. File này chứa các tùy chọn cấu hình cho dự án, bao gồm target
(mục tiêu) biên dịch, các cờ biên dịch (flags), v.v.

\section{{[}target.thumbv7m-none-eabi{]}:}\label{target.thumbv7m-none-eabi}

Phần này xác định các tùy chọn cấu hình cho target thumbv7m-none-eabi,
tương ứng với vi điều khiển ARM Cortex-M3. runner = ``qemu-system-arm
-cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config
enable=on,target=native -kernel'': Câu lệnh này xác định cách chạy
chương trình sau khi biên dịch. Nó sử dụng QEMU, một trình giả lập, để
chạy chương trình trên vi điều khiển Cortex-M3. Các tham số được sử dụng
để cấu hình QEMU, bao gồm loại CPU, loại máy, chế độ hiển thị, v.v.

\subsection{QEMU}\label{qemu}

QEMU (Quick Emulator) là một trình giả lập phần cứng mã nguồn mở, cho
phép bạn chạy các hệ điều hành và ứng dụng được thiết kế cho một kiến
trúc phần cứng khác trên một kiến trúc phần cứng khác. Nói cách khác,
QEMU cho phép bạn mô phỏng một máy tính khác trên máy tính hiện tại của
bạn.

Cách hoạt động của QEMU:

QEMU hoạt động bằng cách tạo ra một môi trường ảo hóa, mô phỏng các
thành phần phần cứng của máy tính mục tiêu, bao gồm:

CPU: QEMU mô phỏng CPU của máy tính mục tiêu, bao gồm các bộ lệnh, bộ
nhớ cache, v.v. Bộ nhớ: QEMU tạo ra một vùng nhớ ảo, mô phỏng bộ nhớ của
máy tính mục tiêu. Thiết bị ngoại vi: QEMU mô phỏng các thiết bị ngoại
vi như ổ cứng, card mạng, card đồ họa, v.v. Sử dụng QEMU:

QEMU có thể được sử dụng cho nhiều mục đích, bao gồm:

Kiểm tra phần mềm: QEMU cho phép bạn kiểm tra phần mềm trên nhiều kiến
trúc phần cứng khác nhau mà không cần phải có phần cứng thực tế. Phát
triển phần mềm: QEMU cho phép bạn phát triển phần mềm cho các hệ điều
hành và kiến trúc phần cứng khác nhau mà không cần phải có phần cứng
thực tế. Giáo dục: QEMU là một công cụ hữu ích cho việc học hỏi về kiến
trúc phần cứng và hệ điều hành. Bảo mật: QEMU có thể được sử dụng để tạo
ra các môi trường ảo hóa an toàn để chạy các ứng dụng nhạy cảm. Ví dụ:

Trong dự án cortex-m-quickstart, QEMU được sử dụng để chạy chương trình
được biên dịch cho vi điều khiển ARM Cortex-M3. Câu lệnh qemu-system-arm
-cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config
enable=on,target=native -kernel trong file .cargo/config.toml xác định
cách chạy chương trình bằng QEMU.

qemu-system-arm: Chạy QEMU cho kiến trúc ARM. -cpu cortex-m3: Sử dụng
CPU Cortex-M3. -machine lm3s6965evb: Sử dụng bo mạch LM3S6965EVB.
-nographic: Không hiển thị giao diện đồ họa. -semihosting-config
enable=on,target=native: Cấu hình chế độ semihosting để cho phép chương
trình tương tác với máy chủ QEMU. -kernel: Chạy chương trình được biên
dịch. Kết luận:

QEMU là một công cụ mạnh mẽ và linh hoạt cho việc mô phỏng phần cứng và
chạy các hệ điều hành và ứng dụng trên các kiến trúc phần cứng khác
nhau. Nó là một công cụ hữu ích cho nhiều mục đích, bao gồm kiểm tra
phần mềm, phát triển phần mềm, giáo dục và bảo mật.

\section{{[}target.'cfg(all(target\_arch = ``arm'', target\_os =
``none''))'{]}:}\label{target.cfgalltarget_arch-arm-target_os-none}

Phần này xác định các tùy chọn cấu hình cho target ARM Cortex-M, được
xác định bởi target\_arch = ``arm'' và target\_os = ``none''. runner =
``arm-none-eabi-gdb -q -x openocd.gdb'': Câu lệnh này xác định cách chạy
chương trình sau khi biên dịch. Nó sử dụng arm-none-eabi-gdb, một trình
gỡ lỗi, để chạy chương trình trong chế độ gỡ lỗi. Các tham số được sử
dụng để cấu hình GDB, bao gồm chế độ im lặng (-q) và file cấu hình (-x
openocd.gdb). runner = ``gdb-multiarch -q -x openocd.gdb'': Câu lệnh này
tương tự như câu lệnh trên, nhưng sử dụng gdb-multiarch thay vì
arm-none-eabi-gdb. runner = ``gdb -q -x openocd.gdb'': Câu lệnh này
tương tự như câu lệnh trên, nhưng sử dụng gdb thay vì arm-none-eabi-gdb
hoặc gdb-multiarch.

\section{rustflags = {[}\ldots{]}:}\label{rustflags}

Phần này xác định các cờ biên dịch (flags) cho Rust. ``-C'',
``linker=arm-none-eabi-ld'': Câu lệnh này xác định trình liên kết
(linker) được sử dụng để liên kết các file đối tượng (object files)
thành file thực thi. Nó sử dụng trình liên kết LLD, được cung cấp bởi
Rust toolchain. ``-C'', ``linker=arm-none-eabi-gcc'': Câu lệnh này xác
định trình liên kết được sử dụng để liên kết các file đối tượng. Nó sử
dụng trình liên kết GCC, được cung cấp bởi toolchain C. ``-C'',
``link-arg=-Wl,-Tlink.x'': Câu lệnh này truyền tham số -Tlink.x cho
trình liên kết. Tham số này được sử dụng để xác định file script liên
kết, chứa thông tin về cách liên kết các file đối tượng. ``-C'',
``link-arg=-nostartfiles'': Câu lệnh này truyền tham số -nostartfiles
cho trình liên kết. Tham số này được sử dụng để ngăn trình liên kết thêm
các file khởi động (startup files) vào file thực thi.

\section{{[}build{]}:}\label{build}

Phần này xác định các tùy chọn cấu hình cho quá trình xây dựng (build).
target = ``thumbv7m-none-eabi'': Câu lệnh này xác định target (mục tiêu)
biên dịch mặc định cho dự án. Nó sử dụng target thumbv7m-none-eabi,
tương ứng với vi điều khiển ARM Cortex-M3. Lưu ý:

File .cargo/config.toml là tùy chọn và không phải lúc nào cũng cần
thiết. Bạn có thể thêm hoặc xóa các phần và tùy chọn cấu hình theo nhu
cầu của dự án. Việc sử dụng file .cargo/config.toml giúp bạn cấu hình dự
án một cách linh hoạt và dễ dàng hơn.

\bookmarksetup{startatroot}

\chapter*{References}\label{references}
\addcontentsline{toc}{chapter}{References}

\markboth{References}{References}

\phantomsection\label{refs}
\begin{CSLReferences}{0}{1}
\end{CSLReferences}

\bookmarksetup{startatroot}

\chapter*{Summary}\label{summary}
\addcontentsline{toc}{chapter}{Summary}

\markboth{Summary}{Summary}

Do thấy có nhiều thuật ngữ khó hiểu khi mới bắt đầu học Rust Embedded,
tôi viết sách này giải thích những thuật ngữ đó trong quá trình học.



\end{document}
